# 最长公共子序列

1143 题。

计算最长公共子序列（Longest Common Subsequence，简称 LCS）是一道经典的动态规划题目，大家应该都见过：

给你输入两个字符串 s1 和 s2，请你找出他们俩的最长公共子序列，返回这个子序列的长度。

比如说输入s1 = "zabcde", s2 = "acez"，它俩的最长公共子序列是lcs = "ace"，长度为 3，所以算法返回 3。

如果没有做过这道题，一个最简单的暴力算法就是，把s1和s2的所有子序列都穷举出来，然后看看有没有公共的，然后在所有公共子序列里面再寻找一个长度最大的。

显然，这种思路的复杂度非常高，你要穷举出所有子序列，这个复杂度就是指数级的，肯定不实际。

正确的思路是不要考虑整个字符串，而是细化到s1和s2的每个字符。前文 子序列解题模板 中总结的一个规律：

对于两个字符串求子序列的问题，都是用两个指针i和j分别在两个字符串上移动，大概率是动态规划思路。

## dp数组的定义

dp[i][j]: text1前i个元素和text2前j个元素的最长公共子序列的长度。

如果 s1[i] == s2[j]，说明这个字符一定在lcs中。

刚才说的s1[i] == s2[j]的情况，但如果s1[i] != s2[j]，应该怎么办呢？

s1[i] != s2[j]意味着，s1[i]和s2[j]中至少有一个字符不在lcs中：

- 情况1：s1[i]不在lcs中。
- 情况2：s2[j]不在lcs中。
- 情况3：都不在lcs中。

总共可能有三种情况，我怎么知道具体是那种情况呢？

其实我们也不知道，那就把这三种情况的答案都算出来，取其中结果最大的那个呗，因为题目让我们算「最长」公共子序列的长度嘛。

这三种情况的答案怎么算？回想一下我们的d数组的定义，不就是专门为了计算它们而设计的嘛！

## 小优化

还有一个小的优化，情况3「s1[i]和s2[j]都不在 lcs 中」其实可以直接忽略。因为情况3中的长度一定是小于情况1和2的。



