# 编辑距离

编辑距离这个问题，它看起来十分困难，解法却出奇得简单漂亮，而且它是少有的比较实用的算法（我承认很多算法问题都不太实用）。

编辑距离问题就是给我们两个字符串 s1 和 s2，只能用三种操作（插入、删除、替换一个字符），让我们把 s1 变成 s2，求最少的操作数。需要明确的是，不管是把 s1 变成 s2 还是反过来，结果都是一样的，所以后文就以 s1 变成 s2 举例。

前文 最长公共子序列 说过，解决两个字符串的动态规划问题，一般都是用两个指针 i,j。

## dp数组定义

dp[i][j]: s1[0...i-1]转化为s2[0...j-1]的最小编辑距离。

## 计算

考虑最后一步。

当 word1[i] == word2[j]，dp[i][j] = dp[i-1][j-1]。

当 word1[i] != word2[j]，dp[i][j] = min(dp[i-1][j-1] + 1, dp[i-1][j] + 1, dp[i][j-1] + 1)。

其中，dp[i-1][j-1] 表示替换操作，dp[i-1][j] 表示删除操作，dp[i][j-1] 表示插入操作。怎么理解呢？

以 word1 为 "horse"，word2 为 "ros"，且 dp[5][3] 为例，即要将 word1的前 5 个字符转换为 word2的前 3 个字符，也就是将 horse 转换为 ros，因此有：

(1) dp[i-1][j-1]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 2 个字符 ro，然后将第五个字符 word1[4]（因为下标基数以 0 开始） 由 e 替换为 s（即替换为 word2 的第三个字符，word2[2]）。

(2) dp[i][j-1]，即先将 word1 的前 5 个字符 horse 转换为 word2 的前 2 个字符 ro，然后在末尾补充一个 s，即插入操作。

(3) dp[i-1][j]，即先将 word1 的前 4 个字符 hors 转换为 word2 的前 3 个字符 ros，然后删除 word1 的第 5 个字符。

## Base case

注意，针对第一行，第一列要单独考虑，我们引入 '' 下图所示：

![](imgs/1.png)

第一行，是 word1 为空变成 word2 最少步数，就是插入操作。

第一列，是 word2 为空，需要的最少步数，就是删除操作。

也就是；

- dp[0][j]: 全部insert，j。

- dp[i][0]: 全部删除，i。

