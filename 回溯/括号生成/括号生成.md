# 括号生成

数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 有效的 括号组合。

## 合法括号的性质

有关括号问题，你只要记住以下性质，思路就很容易想出来：

1. 一个「合法」括号组合的左括号数量一定等于右括号数量，这个很好理解。
2. 对于一个「合法」的括号字符串组合 p，必然对于任何 0 <= i < len(p) 都有：子串 p[0..i] 中左括号的数量都大于或等于右括号的数量。


如果不跟你说这个性质，可能不太容易发现，但是稍微想一下，其实很容易理解，因为从左往右算的话，肯定是左括号多嘛，到最后左右括号数量相等，说明这个括号组合是合法的。

反之，比如这个括号组合 ))((，前几个子串都是右括号多于左括号，显然不是合法的括号组合。

## 回溯

明白了合法括号的性质，如何把这道题和回溯算法扯上关系呢？关键在于问题改写。

算法输入一个整数 n，让你计算 n 对儿括号能组成几种合法的括号组合，可以改写成如下问题：

**现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，组成的所有括号组合中，有多少个是合法的？**

对于 2n 个位置，必然有 n 个左括号，n 个右括号，所以我们不是简单的记录穷举位置 i，而是用 left 记录还可以使用多少个左括号，用 right 记录还可以使用多少个右括号，这样就可以通过刚才总结的合法括号规律进行筛选了：

```
// 题目改写：现在有 2n 个位置，每个位置可以放置字符 ( 或者 )，组成的所有括号组合中，有多少个是合法的？
func generateParenthesis(n int) []string {
	track := make([]byte, 0)
	res := make([]string, 0)
	backtrack(&track, &res, n, n)
	return res
}

// left: 剩下可用的左括号数量
// right：剩下可用的右括号数量
func backtrack(track *[]byte, res *[]string, left, right int) {
	// 可用的左括号更多，说明已经用掉的右括号更多，不合法。参见合法括号的性质
	if right < left {
		return
	}
	// 数量小于 0 肯定是不合法的
	if left < 0 || right < 0 {
		return
	}
	// 当所有括号都恰好用完时，得到一个合法的括号组合
	if left == 0 && right == 0 {
		*res = append(*res, string(*track))
		return
	}
	// 尝试放一个左括号
	*track = append(*track, '(') // 选择
	backtrack(track, res, left-1, right)
	*track = (*track)[:len(*track)-1] // 撤销选择

    // 尝试放一个右括号
	*track = append(*track, ')') // 选择
	backtrack(track, res, left, right-1)
	*track = (*track)[:len(*track)-1] // 撤销选择
}
```

