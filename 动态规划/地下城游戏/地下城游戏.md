# 地下城游戏

输入一个存储着整数的二维数组 grid，如果 grid[i][j] > 0，说明这个格子装着血瓶，经过它可以增加对应的生命值；如果 grid[i][j] == 0，则这是一个空格子，经过它不会发生任何事情；如果 grid[i][j] < 0，说明这个格子有怪物，经过它会损失对应的生命值。

现在你是一名骑士，将会出现在最上角，公主被困在最右下角，你只能向右和向下移动，请问你初始至少需要多少生命值才能成功救出公主？

换句话说，就是问你至少需要多少初始生命值，能够让骑士从最左上角移动到最右下角，且任何时候生命值都要大于 0。

## dp的定义

但是这道题对 dp 函数的定义比较有意思，按照常理，这个 dp 函数的定义应该是：

从左上角（grid[0][0]）走到 grid[i][j] 至少需要 dp(grid, i, j) 的生命值。

接下来我们需要找状态转移了，还记得如何找状态转移方程吗？我们这样定义 dp 函数能否正确进行状态转移呢？

我们希望 dp(i, j) 能够通过 dp(i-1, j) 和 dp(i, j-1) 推导出来。

具体来说，「到达 A 的最小生命值」应该能够由「到达 B 的最小生命值」和「到达 C 的最小生命值」推导出来：

![](imgs/4.png)

但问题是，能推出来么？实际上是不能的。

因为按照 dp 函数的定义，你只知道「能够从左上角到达 B 的最小生命值」，但并不知道「到达 B 时的生命值」。

所以说，我们之前对 dp 数组的定义是错误的，信息量不足，算法无法做出正确的状态转移。

正确的做法需要反向思考，修改 dp 函数的定义：

从 grid[i][j] 到达终点（右下角）所需的最少生命值是 dp(grid, i, j)。

状态转移方程已经推出来了：

```
int res = min(
    dp(i + 1, j),
    dp(i, j + 1)
) - grid[i][j];

dp(i, j) = res <= 0 ? 1 : res;
```

## 注意

- dp数组的初始值应为最大值，这样方便取最小值。
- 对递推式 dp[i][j] 的计算结果，还要多做一步处理，如果结果小于等于0，说明最小血量是1就可以。如果结果大于0，就原样返回。
- 遍历顺序问题，内外循环都是从后往前遍历，是因为每个格子都需要先知道右方、下方的dp结果。
- base case只有dp[m-1][n-1]，最后一行和最后一列的其他值，都要通过递推式计算，所以要写在双层循环内。